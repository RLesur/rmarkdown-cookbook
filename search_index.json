[
["index.html", "R Markdown Cookbook Preface", " R Markdown Cookbook Michael Harper, Yihui Xie 2019-04-22 Preface This book is in a very early stage of development. If you have any suggestions on what should be included within this book, please get in touch via GitHub R Markdown is a powerful tool for combining analysis and reporting into the same document. Since the development of the rmarkdown package (Allaire et al. 2019), it has grown to become a diverse ecosystem of code, and reports, books and websites can all easily be generated directly from R code. There is a wealth of guidance which has grown over the past few years, and the book R Markdown: The Definitive Guide (Yihui Xie 2018) provides an overview of all that can be done with R Markdown. However, as noted by Yihui, it was commented by the publisher that it would be beneficial to provide more practical examples of the use of R Markdown. And so, the idea of this book was born. To fill the gap for official documentation, users often seek for help on StackOverflow. At the time of writing, there were almost 4,000 different questions with the r-markdown tag. However, the use of the website is relatively difficult if you do not have a specific problem you are trying to search for, and therefore it is hard to be able to tell what is possible with R Markdown unless you have the insight to search for a specific question. This book aims to draw together much existing literature from StackOverflow and other details hidden across the internet to provide up-to-date solutions for everyday queries that users commonly face. This book is designed to provide a range of examples of how to extend the functionality of your R Markdown documents. As a cookbook, this guide is recommended to new or intermediate R Markdown users who are looking for practical examples of how R Markdown documents can be effectively updated. References "],
["how-to-read-this-book.html", "How to read this book", " How to read this book The book is designed to highlight the many ways in which your R Markdown documents can be customized. Users are encouraged to try using the concepts within their own documents. The code detailed in the book should be sufficient, but the full source code and examples are provided on GitHub. It is recommended that readers have a basic understanding of R Markdown. Chapter 2 of R Markdown: The Definitive Guide (Yihui Xie 2018) provides a great overview of the basics of R Markdown and is recommended background reading for any new users of R Markdown. It should be noted that this guide does not intend to provide a full technical reference for R Markdown, and there is already extensive literature available on these topics. This book aims to supplement, not replace, this existing literature, and it is therefore recommended that readers explore the following books if they seek further information: R Markdown: The Definitive guide (Yihui Xie 2018): provides an overview of the R Markdown package and the wide range of ways it can be used. Dynamic documents and knitr: provides more detailed technical guidance on the inner workings of rmarkdown and knitr (Xie 2019b). Authoring books with bookdown (Xie 2016): a short book which provides details on the bookdown package (Xie 2018), which is designed to simplify the creation of long-format documents in R Markdown. blogdown: Creating Websites with R Markdown (Xie, Hill, and Thomas 2017): provides details of the blogdown package (Xie 2019a) package. Where relevant, this book provides references to these existing resources. References "],
["structure-of-the-book.html", "Structure of the book", " Structure of the book The book is broken down into small “recipes” which aim to demonstrate a single concept at a time. Chapter content to be finalised once recipes created. "],
["software-info.html", "Software information and conventions", " Software information and conventions The R session information used when compiling this book is as follows: xfun::session_info(c( &#39;bookdown&#39;, &#39;knitr&#39;, &#39;rmarkdown&#39;), dependencies = FALSE) ## R version 3.5.3 (2017-01-27) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 14.04.5 LTS ## ## Locale: ## LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## LC_PAPER=en_US.UTF-8 LC_NAME=C ## LC_ADDRESS=C LC_TELEPHONE=C ## LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## Package version: ## bookdown_0.9 knitr_1.22 rmarkdown_1.12 ## ## Pandoc version: 1.19.2.1 We do not add prompts (&gt; and +) to R source code in this book, and we comment out the text output with two hashes ## by default, as you can see from the R session information above. This is for your convenience when you want to copy and run the code (the text output will be ignored since it is commented out). Package names are in bold text (e.g., rmarkdown), and inline code and filenames are formatted in a typewriter font (e.g., knitr::knit('foo.Rmd')). Function names are followed by parentheses (e.g., blogdown::serve_site()). The double-colon operator :: means accessing an object from a package. “Rmd” is the filename extension of R Markdown files, and also an abbreviation of R Markdown in this book. "],
["acknowledgements.html", "Acknowledgements", " Acknowledgements "],
["installation.html", "Chapter 1 Installation", " Chapter 1 Installation We assume you have already installed R (https://www.r-project.org) (R Core Team 2017) and the RStudio IDE (https://www.rstudio.com). RStudio is not required but recommended, because it makes it easier for an average user to work with R Markdown. If you do not have RStudio IDE installed, you will have to install Pandoc (http://pandoc.org), otherwise there is no need to install Pandoc separately because RStudio has bundled it. Next you can install the rmarkdown package in R: # Install from CRAN install.packages(&#39;rmarkdown&#39;) # Or if you want to test the development version, # install from GitHub if (!requireNamespace(&quot;devtools&quot;)) install.packages(&#39;devtools&#39;) devtools::install_github(&#39;rstudio/rmarkdown&#39;) References "],
["installing-latex-with-tinytex.html", "1.1 Installing LaTeX with TinyTex", " 1.1 Installing LaTeX with TinyTex If you would like to create PDF outputs from R Markdown, you will need to have a LaTeX distribution installed. Although there are several traditional options including MiKTeX, MacTeX, and TeX Live, these can be cumbersome to install if you primarily want to use LaTeX within R Markdown. To make this process easier, TinyTeX is a custom LaTeX distribution based on TeX Live that is small in size (150Mb on macOS/Linux and 220Mb on Windows) but functions well in most cases, especially for R users. Installing or running TinyTeX does not require admin privileges, which means you no longer need sudo or your IT. If you want to use TinyTeX, we recommend that you first uninstall your existing LaTeX distribution. The tinytex R package (Xie 2019c) can be used to install TinyTeX: install.packages(&#39;tinytex&#39;) tinytex::install_tinytex() # to uninstall TinyTeX, run tinytex::uninstall_tinytex() References "],
["basics.html", "Chapter 2 Basics", " Chapter 2 Basics This book by no means intends to be a comprehensive guide to R Markdown, however before we start, it is important to provide an overview of the R Markdown ecosystem before we explain how to make changes to it. This chapter therefore aims to provide the basic concepts required for the book. For those seeking the background, we recommend that readers refer to The R Markdown Definitive Guide of Yihui Xie (2018), which provides a comprenhensive overview of the R Markdown components. References "],
["r-markdown-components.html", "2.1 R Markdown components", " 2.1 R Markdown components R Markdown combines several different processes together to create documents, and one of the main sources of confusion from R Markdown is how all the components work together. Fortunately, as a user, it is not essential to understand all the inner workings of these processes to be able to create documents. However, as a user who may be seeking to alter the behaviour of a document, it is important to understand the components which part is responsible for what. This makes it a lot easier to seek help as you can target your searches on the correct area. The basic workflow structure for an R Markdown document is shown in Figure 2.1, highlighting the processes (arrows) and the intermediate files which are created before producing the output. Each stage is explained in further detail below. Figure 2.1: Schematic highlighting the R Markdown workflow. (DRAFT DIAGRAM) The .Rmd document is the original format of the document. It contains a combination of YAML, text and code chunks. knitr is used to convert any code embedded within the .Rmd file. This will run all the R code contained within the report and prepare the outputs to be displayed within the output results. All these results are converted into the correct markup language to be contained within the temporary .md file. The .md file is processed by pandoc, a multipurpose tool which is designed to convert files from one markup language to another. This takes any parameters specified within the YAML frontmatter of the document (e.g. title, author, date) to convert the document to the output format specified in the output argument (HTML/PDF/Word). If the output document is PDF, there is an additional layer of processing, as Pandoc will convert the raw .md into an intermediate .tex file. This file is then processed by LaTeX to form the final PDF document. As a final clarification, the bookdown package is often used within more complex, multiple file books such as this. This essentially provides a layer of preprocessing to the R Markdown document which extends the functionality of the rmarkdown package. "],
["formatting.html", "Chapter 3 Formatting", " Chapter 3 Formatting One of the strengths of the markdown language is that it’s simplicity makes it very easy to read even to newcomers to understand. This is one of its key design principles, and as outlined creator of the markdown language: A Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. – John Gruber However, this comes at a cost of customisation, and many of the features which users of typical word processors are used to are not directly accessible. This includes: Changing font size Changing font colour Editing font alignment Indenting text It can be helpful for such features to be included within documents. This chapter provides an extended guide to the basics of the R Markdown language, and highlights how we can customise the appearance and styling within an R Markdown document. If you need a reminder in the basics of the markdown language, the R Markdown cheatsheet provides a good overview of the basic syntax. "],
["changing-font-colour.html", "3.1 Changing Font Colour", " 3.1 Changing Font Colour The markdown syntax has no built-in method for changing text colours. We can use HTML and LaTeX syntax to change the formatting of words: For HTML: we can wrap the text in the &lt;font color='&quot;,color,&quot;'&gt;&quot;,x,&quot;&lt;/font&gt; command. For PDF: we can use the LaTeX command \\textcolor{}{}. This requires the extra LaTeX package xcolor. As an example of changing the colour in PDF text: --- output: pdf_document: extra_dependencies: [&quot;xcolor&quot;] --- Roses are \\textcolor{red}{red}, violets are \\textcolor{blue}{blue} 3.1.1 Multi-output text colour We should attempt to design our R Markdown documents to allow for multiple outputs. If we embed raw HTML or LaTeX code into our documents, this formatting will be ignored in the other output format. We can write a custom function which will insert the correct syntax depending on the output format using the is_latex_output() and is_html_output functions as follows: format_with_col = function(x, color){ if(knitr::is_latex_output()) paste(&quot;\\\\textcolor{&quot;,color,&quot;}{&quot;,x,&quot;}&quot;,sep=&quot;&quot;) else if(knitr::is_html_output()) paste(&quot;&lt;font color=&#39;&quot;,color,&quot;&#39;&gt;&quot;,x,&quot;&lt;/font&gt;&quot;,sep=&quot;&quot;) else x } We can then use the code as an inline R expression format_with_col(&quot;red&quot;, &quot;red&quot;) which will create red text. "],
["comment-out-content.html", "3.2 Comment out content", " 3.2 Comment out content It is useful to include commented text within the source document which is not displayed within the final outputted document. We can use the HTML syntax &lt;!--- your comment ---&gt;. This will not be displayed in any output format. Comments can span either single or multiple lines. This may be useful if you have draft comment, and it also allows us to comment out code chunks (and prevent them from being run in knitr). "],
["indenting-text.html", "3.3 Indenting text", " 3.3 Indenting text Markdown will ignore indentations by default. However, we may want to keep indentation within the text, for example within verses and addresses. In these situations, we can use line blocks by starting the line with a vertical bar (|). The division into lines will be preserved in the output, as will any leading spaces; otherwise, the lines will be formatted as Markdown. As an example: | The limerick packs laughs anatomical | In space that is quite economical. | But the good ones I&#39;ve seen | So seldom are clean | And the clean ones so seldom are comical The lines can be hard-wrapped if needed, but the continuation line must begin with a space. For example: | The Right Honorable Most Venerable and Righteous Samuel L. Constable, Jr. | 200 Main St. | Berkeley, CA 94718 "],
["verbatim-code-chunks.html", "3.4 Verbatim code chunks", " 3.4 Verbatim code chunks Typically we write code chunks and inline expressions that we want to be parsed and evaluated by knitr. However, if you are trying to write a tutorial on using knitr, you may need to generate verbatim code chunk or inline expression that is not parsed by knitr, and we want to display the content of the chunk header. Unfortunately, we can’t wrap the code chunk in another layer of backticks, but instead we must make the code chunk invalid within the source code by inserting “`` `` to the chunk header. This will be evaluated as an inline expression to an empty string by knitr. For this example, the following”code chunk&quot; in the source document: ```{r, eval=TRUE}`r &#39;&#39;` 1 + 1 ``` will be rendered as: ```{r, eval=TRUE} 1 + 1 ``` in the output. The inline expression is gone because it is substituted by an empty string. However, that is only the first step. To show something verbatim in the output, the syntax in Markdown is to wrap it in a code block (indent by four spaces or use backtick fences). This will be the actual source if you want to see the output above: ```` ```{r, eval=TRUE}`r &#39;&#39;` 1 + 1 ``` ```` Why four backticks? That is because you have to use at least N+1 backticks to wrap up N backticks. 3.4.1 Show a verbatim inline expression There are multiple ways to show a verbatim inline expression. I mentioned this trick for R Markdown documents in the FAQ: This will show a verbatim inline R expression `` `r 1+1` `` in the output. The trick works due to two reasons (1) a single line break is often the same as a space to Markdown parsers (by comparison, two consecutive line breaks means starting a new paragraph); (2) knitr requires a space after `r to parse it; if the space is missing, it will not be treated as an inline expression. In the output document, you should see: This will show a verbatim inline R expression 2 in the output. You can read more about this behaviour here. "],
["document-elements.html", "Chapter 4 Document Elements", " Chapter 4 Document Elements There are lots of small tips and tricks that can be used to customize the content of R Markdown documents. This chapter provides short recipes which are useful for tweaking the behaviour of your own R Markdown documents. "],
["bibliographies-and-citations.html", "4.1 Bibliographies and citations", " 4.1 Bibliographies and citations R Markdown makes it easy include citations within your document by using pandoc. For a comprehensive overview, we recommend Section 2.8 of Xie (2016). However, the basic usage requires us to specify a bibliography file using the bibliography metadata field in the YAML. For example: --- output: html_document bibliography: references.bib --- where the A BibTeX database is a plain-text file that consists of bibliography entries like this: @Manual{R-base, title = {R: A Language and Environment for Statistical Computing}, author = {{R Core Team}}, organization = {R Foundation for Statistical Computing}, address = {Vienna, Austria}, year = {2016}, url = {https://www.R-project.org/}, } Items can be cited directly within the documentation using the first line @R-base. 4.1.1 Changing citation style By default, pandoc will use a Chicago author-date format for citations and references. To use another style, you will need to specify a CSL 1.0 style file in the csl metadata field: --- output: html_document bibliography: references.bib csl: biomed-central.csl --- To find your required formats, we recommend using the Zotero website, which makes it search for and download your required style. Although beyond the scope of the book, it is worth highlighting that the behaviour of CSL files can be tweaked to customise the behaviour as required. For example, we can change the number of authors required before “et.al” is used to abbreviate them. This can be simplified through the use of visual editors such as the one found here. 4.1.2 Add item to bibliography without using it By default, the bibliography will only display items which are directly referenced in the document. If you want to include items in the bibliography without actually citing them in the body text, you can define a dummy nocite metadata field and put the citations there. This can be included anywhere in the document but it is normally best to place it at the end of the document: # References --- nocite: | @item1, @item2 ... 4.1.3 Add all items to bibliography If we do not wish to explicitly state all of the items within the bibliography but would still like to show them in our references, we can use the following syntax: --- nocite: &#39;@*&#39; ... This will force all items to be displayed in the bibliography. 4.1.4 Include appendix after bibliography By default, the bibliography appears at the very end of the document. However, there can be cases where we want to place additional text after the references, most typically if we wish to include appendices within the document. We can force the position of the references by using &lt;div id=&quot;refs&quot;&gt;&lt;/div&gt;, as shown below: # References &lt;div id=&quot;refs&quot;&gt;&lt;/div&gt; # Appendices We can improve this further by using the bookdown package, which offers a special header for the Appendix as shown with the syntax below: # References &lt;div id=&quot;refs&quot;&gt;&lt;/div&gt; # (APPENDIX) Appendix {-} # Appendix A # Appendix B The numbering style of appendices will be automatically changed in LaTeX/PDF and HTML output (usually in the form A, A.1, A.2, B, B.1, …). References "],
["crossRef.html", "4.2 Cross-referencing within documents", " 4.2 Cross-referencing within documents Cross-referencing is a useful way of directing your readers through your document, and can be automatically done within R Markdown. While this is explained in Section 2.6 from the bookdown book (Xie 2016), it is useful to remind readers of how to use these within documents. To use cross-references, we must: Use a bookdown output format: cross-referencing is not provided directly within the base rmarkdown, but is provided as an extension. We must therefore use an output format (e.g. html_document2, pdf_document2, word_document2) include this in the YAML output field. A caption to your figure or table: figures without a caption will be included directly as images and will therefore not be a numbered figure. A named code chunk: this provides our identifier for referencing the chunk from within the text. Having met these conditions, we can make cross-references within the text using the format \\@ref(type:label), where label is the chunk label and type is the environment being referenced (e.g. tab, fig, eqn). An example is provided below: --- output: bookdown::html_document2 --- See Figure \\@ref(fig:cars-plot) ```{r cars-plot, fig.cap=&quot;A plot caption&quot;} plot(cars) # a scatterplot ``` See Table \\@ref(tab:mtcars) ```{r mtcars} knitr::kable(mtcars[1:5, 1:5], caption = &quot;A caption&quot;) ``` The output of this document is shown in Figure 4.1. Figure 4.1: Example of cross-referencing within an R Markdown document We can also cross-reference equations, theorems and section headers, which are explained further in Section 12.3.5 of the R Markdown book (Yihui Xie 2018). References "],
["automatically-update-document-date.html", "4.3 Automatically update document date", " 4.3 Automatically update document date It may be useful for the date of the knitted R Markdown document to automatically update each time we rerun the file. To do this, we can add R code directly to the date field in the YAML, and use the Sys.time() function to extract the current date. As this function will by default provide the date and time, we must specify the desired date time format as shown below: --- date: &quot;`r format(Sys.time(), &#39;%d %B, %Y&#39;)`&quot; --- This will automatically update each time you Knit your document i.e. 22 April, 2019. If we wish to customize the format of the dates, we can alter the time format by providing our own text string. Some examples are shown as follows: %B %Y: April 2019 %d/%m/%y: 22/04/19 %a/%d/%b: Mon 22 Apr A full table of POSIXct formats is shown in Table 4.1, which allows users to construct their required date format. Table 4.1: Date Time Formats within R Code Meaning Code Meaning %a Abbreviated weekday %A Full weekday %b Abbreviated month %B Full month %c Locale-specific date and time %d Decimal date %H Decimal hours (24 hour) %I Decimal hours (12 hour) %j Decimal day of the year %m Decimal month %M Decimal minute %p Locale-specific AM/PM %S Decimal second %U Decimal week of the year (starting on Sunday) %w Decimal Weekday (0=Sunday) %W Decimal week of the year (starting on Monday) %x Locale-specific Date %X Locale-specific Time %y 2-digit year %Y 4-digit year %z Offset from GMT %Z Time zone (character) As a final note, you may even want to include some explanatory text along with the date. We can easily add any text such as “Last Compiled on” before the R code as follows: --- date: &quot;Last compiled on `r format(Sys.time(), &#39;%d %B, %Y&#39;)`&quot; --- "],
["adding-multiple-authors-to-document.html", "4.4 Adding multiple authors to document", " 4.4 Adding multiple authors to document We can add multiple authors to a R Markdown document within the YAML in a number of ways. If we simply want to list them on the same line, we can provide a text string to the document: --- title: &quot;Untitled&quot; author: &quot;John Doe, John Smith&quot; --- Alternatively, if we wish for each entry to be on its own line we can provide a list of entries to the YAML field. This can be useful if you wish to include further information about each author such as an email address or instituion: --- author: - John Doe, Institution One - John Smith, Institution Two --- We can make use of the markdown syntax ^[] to add additional information as a footnote to the document. This may be more useful if you have extended information you wish to include for each author, such as providing a contact email, address etc. The exact behaviour will depend on the output format (HTML/PDF/Word): --- author: - John Doe^[Institution One, email@domain.com] - John Doe 2^[Institution Two, email2@domain.com] --- Certain R Markdown templates will allow you to specify additional parameters directly within the YAML. For example, the Radix output format allows url, affiliation and affiliation_url to be specified. We must first install the Radix package from GitHub: devtools::install_github(&quot;rstudio/radix&quot;) We can use the new format by changing the output option as specified below: --- title: &quot;Radix for R Markdown&quot; author: - name: &quot;JJ Allaire&quot; url: https://github.com/jjallaire affiliation: RStudio affiliation_url: https://www.rstudio.com output: radix::radix_article --- "],
["adding-numbered-figure-captions.html", "4.5 Adding numbered figure captions", " 4.5 Adding numbered figure captions We can use the bookdown to add figure numbers to the figure captions. An example is provided below: --- output: bookdown::html_document2 --- ```{r cars, fig.cap = &quot;An amazing plot&quot;} plot(cars) ``` ```{r cars2, fig.cap = &quot;Another amazing plot&quot;} plot(cars) ``` Section 4.2 demonstrates how we can extend this further by cross-referencing the numbered figures within the text. "],
["knitr.html", "Chapter 5 Knitr", " Chapter 5 Knitr "],
["allow-duplicate-code-chunks.html", "5.1 Allow duplicate code chunks", " 5.1 Allow duplicate code chunks By default, knitr will not allow duplicate code chunks names in the document, and will result in an error when the document is knitted. This most frequently occurs when a code chunk is copy-and-pasted within a document. Most R Markdown users will have seen an error message like this at some stage: processing file: myfile.Rmd Error in parse_block(g[-1], g[1], params.src) : duplicate label &#39;cars&#39; Calls: &lt;Anonymous&gt; ... process_file -&gt; split_file -&gt; lapply -&gt; FUN -&gt; parse_block Execution halted However, there are scenarios where we may wish to allow duplicate cases. For example, if we have one master document parent.rmd and several child documents, each with a number of chunks. If I attempt to re-use the same child-chunks, however, this will fail: # settings settings = list(...) # run once knit_child(&#39;useful_analysis.rmd&#39;) # new settings settings = list(...) # run again knit_child(&#39;useful_analysis.rmd&#39;) In such scenario, we can allow duplicate labels: options(knitr.duplicate.label = &#39;allow&#39;) Note, it is not recommended that this option is set in documents without valid reason. As with most error messages, they are there for a reason, and allowing duplicate chunks can create issues with figures and cross-references. You have been warned! "],
["exit-knitting-early.html", "5.2 Exit Knitting Early", " 5.2 Exit Knitting Early Sometime we may want to exit knitting early and not at the end of the document. For example, we may be working on some analysis and only wish to share the first half of the results, or we may still be working on code at the bottom which is not yet complete. In these situations, we could consider using the knit_exit function, which will end the knitting process at that location. Below is a simple example, where we have a very simple chunk followed by a more time-consuming one: ```{r} library(knitr) 1 + 1 knit_exit() ``` Okay, you will not see me in the output. ```{r} Sys.sleep(100) ``` Normally you have to wait for 100 seconds, but since we have called knit_exit(), the rest of the document is actually ignored. "],
["customising-knitr-options.html", "5.3 Customising knitr options", " 5.3 Customising knitr options There are more than 40 different chunk options which can be used to fine-tune the behaviour of knitr when processing R chunks. Section 2.8 of Yihui Xie (2018) provides a subset of these, while the full list of these variables is available at https://yihui.name/knitr/options/. This section aims to provides some useful recipes on some commonly used configurations within R Markdown documents. 5.3.1 Hide code and all outputs We often wish to setup our R Markdown documents by loading a series of packages. Instead of using separate commands to R source code (echo=FALSE), hide text output (results='hide'), hide warnings (warnings=FALSE), hide messages (messages=FALSE) and so on, we can suppress all forms of output elements using the include=FALSE setting as shown below: ```{r, include=FALSE} ``` With include=FALSE, the code chunk will be evaluated (unless eval=FALSE), but the output will be completely suppressed. 5.3.2 Remove hashes from code output By default, R code output will have hashes # inserted in front of the outputted code. We can alter this behaviour by using the comment chunk option. If we only want to change the output for a single block we can include it directly within the code block. For example: ```{r include=FALSE, comment = NA} plot(cars) ``` It is typically more useful to change this globally, so that all your code chunks have the same appearrance. We can change this globally using the opts_chunk$set option: ```{r include=FALSE} knitr::opts_chunk$set(comment = NA) ``` References "],
["latex.html", "Chapter 6 LaTeX", " Chapter 6 LaTeX For many authors, the main output of their work will be the PDF report, and will be able to utilise the styling of LaTeX. In this chapter, we discuss approaches which can be used to customise the output of PDF reports. Users should approach with a note of caution. One of the major benefits of R Markdown is the fact that a single source document can create documents with multiple formats. By tailoring your work to a single output format (PDF/Word/HTML), you may improve the appearance and performance of a single output but at the expense of this tranferability. "],
["add-logo-to-title-page.html", "6.1 Add logo to title page", " 6.1 Add logo to title page We can use the titling LaTeX package to alter our title block to include an image. We can include the following lines of text in our YAML, where we change the my-image with your local image file: - \\usepackage{titling} - \\pretitle{\\begin{center}\\LARGE\\includegraphics[width=6cm]{my-image}\\\\[\\bigskipamount]} - \\posttitle{\\end{center}} An example output is shown in Figure 6.1. Figure 6.1: Example LaTeX title with logo "],
["include-additional-latex-packages.html", "6.2 Include additional LaTeX packages", " 6.2 Include additional LaTeX packages If your primary output format for your R Markdown document is PDF, then the use of additional LaTeX packages can allow for extensive customization of document styling. In addition, several packages such as kableExtra may have LaTeX dependencies for the R package to function. Much like R, we need to load packages within the R Markdown document before we are able to use their functions. 6.2.1 Loading LaTeX Packages We can load additional LaTeX packages using the extra_dependencies option within the pdf_document YAML settings. This allows us to provide a list of R Markdown packages: --- title: &quot;Untitled&quot; output: pdf_document: extra_dependencies: [&quot;bbm&quot;, &quot;threeparttable&quot;] --- If you need to specify options when loading the package, you can add a second-level to the list and provide the options as a list: output: pdf_document: extra_dependencies: caption: [&quot;labelfont={bf}&quot;] hyperref: [&quot;unicode=true&quot;, &quot;breaklinks=true&quot;] lmodern: null For those familiar with LaTeX, this is equivalent to the following LaTeX file: \\usepackage[labelfont={bf}]{caption} \\usepackage[unicode=true, breaklinks=true]{hyperref} \\userpackage{lmodern} 6.2.2 Example Packages There is an extensive community for LaTeX, and there are over 4,000 packages available through the Comprohensive Tex Archive Network (CTAN). As some examples of LaTeX packages you could consider using within your analysis: pdfpages: include full PDF pages within your document. This is useful if you wish to have appendices within your document caption: change the appearance of caption subtitles. For example, you can make the Figure title italics, centered. fancyhdr: change the style of page headers. "],
["controlling-the-placement-of-figures.html", "6.3 Controlling the Placement of Figures", " 6.3 Controlling the Placement of Figures One of the common frustrations with LaTeX is how Figures and Tables are handled. Unlike in a word processor like Microsoft Word, LaTeX will attempt to place the figure in a position on the page which leads to the least amount of whitespace being added. In doing so, it can result in large gaps appearing between where the originally created, and where it is placed in the report. To new users of LaTeX, the behaviour of figure positioning can be fairly confusing and it is not clear how floats work. Floats are used as containers for things which cannot be broken over a page, such as tables and figures. You may run into some problems if you have multiple figures in rapid sucession, as this raises the problem of how they are supposed to fit on the page and still leave room for text. In this case, LaTeX stacks them all up and prints them together if possible, or leaves them to the end of the chapter in protest. The skill is to space them out within your text so that they intrude neither on the thread of your argument or discussion, nor on the visual balance of the typeset pages. "],
["add-custom-headers-and-footers.html", "6.4 Add Custom Headers and Footers", " 6.4 Add Custom Headers and Footers We can use LaTeX package fancyhdr to customise the header and footer of PDF outputs. It provides several commands that allow you to customize the header and footer lines of your document. For a more complete guide, please refer to the full documentation. To begin with, we must load the package and change the header style: \\usepackage{fancyhdr} \\pagestyle{fancy} The package offers three different interfaces, but we will use the commands \\fancyhead and \\fancyfoot. The syntax for the formatting \\fancyhead[selectors]{output text}, whereby the selectors state which part of the header we wish to customize. We can use the following selectors for the page locators: E for even page O for odd page L for left side C for centered R for right side For example, \\fancyhead[LE,RO]{Your Name} will print the text “Your Name” on the Left side of the header for Even pages, and the Right side for Odd pages. We can combine this with additional LaTeX commands to extract details from our document for each page: \\thepage: adds number of the current page. \\thechapter: adds number of the current chapter. \\thesection: adds number of the current section. \\chaptername: adds the word “Chapter” in English or its equivalent in the current language. \\leftmark: adds name and number of the current top-level structure in uppercase letters. \\rightmark: adds name and number of the current next to top-level structure in uppercase letters. Piecing this components together, a complete example is presented below. This could be inserted in the document, or another header.tex file : \\usepackage{fancyhdr} \\pagestyle{fancy} \\fancyhead[CO,CE]{Your Document Header} \\fancyfoot[CO,CE]{And this is a fancy footer} \\fancyfoot[LE,RO]{\\thepage} If in an external .tex file, then it could be included in the header of our rmarkdown::pdf_document format: --- title: &quot;Document with header and footer&quot; output: pdf_document: includes: in_header: header.tex --- The includes feature of pdf_document is presented in Advanced customisation of Yihui Xie (2018). An alternative,1 it could also be included directly in header to a rmarkdown document within the YAML using the pandoc variable header-includes: --- header-includes: - \\usepackage{fancyhdr} - \\pagestyle{fancy} - \\fancyhead[CO,CE]{Your Document Header} - \\fancyfoot[CO,CE]{And this is a fancy footer} - \\fancyfoot[LE,RO]{\\thepage} output: pdf_document --- 6.4.1 Force Header and footer for every page By default, headers and footers will not be displayed on the first page of your PDF document. If we wish to show our footer on the front page, we must include an additional line \\fancypagestyle{plain}{\\pagestyle{fancy}}. As an example in the YAML frontmatter specification --- header-includes: - \\usepackage{fancyhdr} - \\pagestyle{fancy} - \\fancyhead[CO,CE]{YOur Document Header} - \\fancyfoot[CO,CE]{And this is a fancy footer} - \\fancyfoot[LE,RO]{\\thepage} - \\fancypagestyle{plain}{\\pagestyle{fancy}} output: pdf_document --- References "],
["latex-subfigures.html", "6.5 LaTeX subfigures", " 6.5 LaTeX subfigures When writing a document you may want to include some slightly more complicated figures with multiple images. Subfigures are a useful LaTeX feature which allows us to achieve this by plotting multiple figures within a single plot and providing each with their own subcaption. Subfigures require the LaTeX package subfig. We can load this via the extra_dependencies YAML option within the pdf_document output. For example: --- output: pBdf_document: extra_dependencies: subfig --- As listed within the knitr chunk options, subfigures require a few additional settings to be set in the chunk header: fig.subcap is a list of the captions for subfigures fig.ncol: the number of columns of subfigures out.width: the output width of the figures. You will normally set this 100% divided by the number of sub columns. An example is demonstrated below: --- output: pdf_document: extra_dependencies: subfig --- ```{r fig-sub, fig.cap=&#39;two plots&#39;, fig.subcap=c(&#39;one plot&#39;, &#39;the other one&#39;), out.width=&#39;.49\\\\linewidth&#39;, fig.asp=1, fig.ncol = 2} plot(1:10) plot(rnorm(10), pch=19) ``` The output is shown in Figure 6.2. Figure 6.2: An example subcaption "],
["html-output.html", "Chapter 7 HTML Output", " Chapter 7 HTML Output How to customise the appearance of HTML outputs. "],
["change-chunk-styling.html", "7.1 Change Chunk Styling", " 7.1 Change Chunk Styling We can customize the style of code chunks and outputs using the arguments class.source and class.output. One way this can be useful is motivated by the original Stack Overflow question on how we use knitr to help us to emphasize “bad” coding practices. By default, R Markdown will include the Bootstrap framework. This can make things very easy for you to signify your code and your output. Bootstrap defines some CSS classes for backgrounds: &quot;bg-primary&quot;, &quot;bg-success&quot;, &quot;bg-info&quot;, &quot;bg-warning&quot;, and &quot;bg-danger&quot;. For example, we are warned that the normal subsetting of a data frame can be type-unstable. To show this here, the chunk options are set: class.source = 'bg-warning', class.output = 'bg-warning'. ```{r df-drop, class.source=&#39;bg-warning&#39;, class.output=&#39;bg-warning&#39;} mtcars[, &quot;mpg&quot;] ``` In our output document, this will create the code chunk as shown in Figure 7.1. Figure 7.1: Output of customised code chunk To make sure that we return a data frame, we set the argument drop = FALSE. Here the chunk options are set: class.source = 'bg-success', class.output = 'bg-success'. ```{r df-drop-ok, class.source=&#39;bg-success&#39;, class.output=&#39;bg-success&#39;} mtcars[, &quot;mpg&quot;, drop=FALSE] ``` 7.1.1 Using Custom CSS If we wish to specify custom styling options, we can include a CSS file by setting a parameter in the YAML header (reference). You can also include a chunk of CSS code, as is done here. Note that for this example, only class.source is set. ```{css echo=FALSE} .chunk-style{ background-color: #F5B7B1; border: 1px solid #797D7F; border-radius: 1px;} ``` ```{r df-drop-2, class.source=&#39;chunk-style&#39;} mtcars[, &quot;mpg&quot;] ``` The output style is shown in Figure 7.2. Figure 7.2: Custom Background styling as defined by CSS 7.1.2 Setting Default Style for Document If we wish for all code chunks in the document to use our newly created style, we can add the class.source to the global knitr options.: knitr::opts_chunk$set(class.source=&#39;chunk-style&#39;) "],
["html-scroll.html", "7.2 Scrollable Code Chunks", " 7.2 Scrollable Code Chunks If we are including large amounts of code within our documents, we may want the code chunks to be limited in height with a scroll bar to navigate through the full details. Such a code chunk is highlighted in Figure 7.3. Here we demonstrate several ways in which this behaviour could be implemented. Figure 7.3: A Scrollable Code chunk using custom CSS 7.2.1 Overwriting the Default CSS The simplist way of adding a scroll bar is to overwrite the global CSS options for the document. This will change the behaviour of all code chunks within the document. This requires us to specify the following CSS, where the user can set the height of the box using the max-height option: pre { max-height: 300px; float: left; width: 910px; overflow-y: auto; } pre.r { max-height: none; } 7.2.2 Specifing Additional CSS If you would desire more control over when the scroll bar is used, you may prefer to specify another style class which we can used when required. Below, we have created an additional class called ‘scroll’ which we can include within our R Markdown document: .scroll { max-height: 300px; float: left; width: 910px; overflow-y: auto; } To use this class, we can specify the ‘class.output’ option within the code chunk header: ```{r, class.output = &quot;scroll&quot;} print(cars) ``` 7.2.3 User-specified chunk height This example is extended further within Section 14.1, which uses chunk hooks to allow for user-specified heights. "],
["tabbed-headings.html", "7.3 Tabbed headings", " 7.3 Tabbed headings "],
["word.html", "Chapter 8 Word", " Chapter 8 Word "],
["multi-format-projects.html", "Chapter 9 Multi-format projects", " Chapter 9 Multi-format projects One of the main benefits of R Markdown can create multiple output formats from a single source document. This book example is available in all three formats, with PDF, ebook and online versions all being available. Project should therefore ideally be designed to be flexible for the multiple outputs. However, users will often find themselves wanting to fine-tune the output, and doing so will often require This chapter aims to provide several examples on how a document can be customised with output specific features, whilst also retaining the ability to export documents to multiple formats. "],
["output-specific-functions.html", "9.1 Output-specific functions", " 9.1 Output-specific functions HTML documents have the capacity to contain. The webshot package is available to take screenshots of HTML elements for non-interactive output formats (ebooks, PDF). library(ggplot2) library(plotly) p &lt;- ggplot(data = diamonds, aes(x = cut, fill = clarity)) + geom_bar(position = &quot;dodge&quot;) ggplotly(p) "],
["designing-output.html", "9.2 Designing output", " 9.2 Designing output If we wish to design our own format-specific function we can use the functions knitr::is_latex_output() and knitr::is_html_output. These function will return a TRUE/FALSE action knitr::is_html_output() This can be used to control the output of statements. For example, you may want to have interactive tables using DT:datatable in the HTML output but print static versions in the PDF. "],
["using-custom-blocks.html", "9.3 Using Custom Blocks", " 9.3 Using Custom Blocks Section 2.7 of Xie (2016) highlighted how we can use custom blocks in R Markdown to customise the appearance of sections of text. They can be a useful way to make some text stand out from your reports or books, and are a great way to make sure that your readers take away the key points from your work. As some examples of how these could be used: Add a warning to let users know to make sure users are using up-to-date packages before running your analysis: Add a link at the start of your document to your GitHub repository containing code: To highlight key results and findings from your analysis: In this section, we will explain how to create your own custom blocks for both PDF and HTML outputs. They can both use the same formatting within the R Markdown document, but require slight different configurations in your project for this to work. You may wish to explore the customBlocks repository on GitHub which provides a minimal example of the code highlighted in this section. 9.3.1 Basic Structure We can generate a custom block using either the block2 engine in knitr. We must also specify the chunk option type, which specifies the class of the &lt;div&gt; and the name of the LaTeX environment. For example: ```{block, type=&#39;FOO&#39;} Some text for this block. ``` It is up to the user to define their own &lt;div&gt; in CSS for the HTML output, or \\newenvironment in LaTeX for PDF outputs. These customisations will normally be contained in their own files such as style.css or preamble.tex, and then included within the YAML options: --- output: bookdown::html_book: css: style.css bookdown::pdf_book: includes: in_header: preamble.tex --- With this basic setup, we will demonstrate several custom blocks that we can be used to create custom blocks for your work. 9.3.2 Adding a Shaded Box First we will highlight how we can add a shaded box for our content. Both HTML and PDF outputs allow for quite a lot of customisation of our custom blocks, and it should allow you to sufficient choice in customising the styles to match if you would like consistency across your outputs. For the HTML output, we will specify our custom class in the style.css file. If you are unfamiliar with CSS, you may want to search for options using this link to see what we can easily control. For example, we create a greyed out box with a red border, adding curved corners to the box: .customBlock { padding: 1em 1em 1em 1em; margin-bottom: 10px; background: #F8F9F9; border-color: #A93226; border-style: solid; border-radius: 10px; border-width: thin; } .customBlock { padding: 1em 1em 1em 1em; margin-bottom: 10px; background: #F8F9F9; border-color: #A93226; border-style: solid; border-radius: 10px; border-width: thin; } For the LaTeX output, we will add our custom block to the preamble.tex file. We will use use the tcolorbox LaTeX package, which offers quite a flexible set of options for creating shaded boxes, as detailed within the package documentation. Below, we create a new environment called customBlock, with a similar design of that outlined above: \\usepackage[many]{tcolorbox} \\usepackage{graphicx} \\usetikzlibrary{calc} % Define the colours to match the CSS above \\definecolor{background}{HTML}{F8F9F9} \\definecolor{border}{HTML}{A93226} % Create our custom box \\newtcolorbox{customBlock}{ colback = background, colframe = border, boxsep=5pt, arc=4pt} By using the chunk header {block2, type = &quot;customBlock&quot;}, we can now use our custom block design in both PDF and HTML output formats. This is shown as follows: Look at our custom block! 9.3.3 Including Images We can make custom blocks even more visually appealing by including images in them, and it can be an effective way to convey the content of the block. For the following examples, we will assume we are working within a directory below which is a simplified version what is used to build the book: directory/ ├── yourReport.Rmd ├── style.css ├── preamble.tex └── images/ └── icons/ └── ├── important.png ├── note.png └── caution.png For the HTML output, we can add an image to the box by adding background-image. The image is inserted into the background, and the padding is offset on the right-hand side to avoid the text overlapping this image. If you are using local images, the file path to the images is provided relative to the CSS file. For example: .rmdcaution{ padding: 1em 1em 1em 4em; margin-bottom: 10px; background: #f5f5f5 5px center/3em no-repeat; background-image: url(&quot;images/icons/caution.png&quot;); } If you want to have a consistent styled box but have different icons, we can globally assign the CSS style to several custom blocks and then add the image for each block seperately. This approach is used within the source code of this book, as we can define multiple styles without repeating the same basic formatting, as follows: .rmdcaution, .rmdimportant, .rmdnote, .rmdtip, .rmdwarning { padding: 1em 1em 1em 4em; margin-bottom: 10px; background: #f5f5f5 5px center/3em no-repeat; } .rmdcaution { background-image: url(&quot;images/icons/caution.png&quot;); } .rmdimportant { background-image: url(&quot;images/icons/important.png&quot;); } For the PDF output, we can adapt the tcolorbox code shown above to add the image to the left side of the box, whereby some slight adjustments are made to offset the text from the left and to insert the image into the box. As for the HTML, if we want to create multiple custom blocks of a similar style, it is generally more useful to make a more general function which can be used to create each block. Below, we demonstrate the use of this, where a new environment customBlockImage is created which is then used to build our final environments that we wish to use in our report (rmdnote, rmdimportant): % Create our general design \\newtcolorbox{customBlockImage}[2][]{ enhanced, top=10pt, bottom=10pt, colframe = white, width=\\textwidth, boxsep=5pt, arc=4pt, outer arc=4pt, leftupper=1.5cm, overlay={ \\node[anchor=west] at ([xshift=10pt] $ (interior.north west)!0.5!(interior.south west) $ ) {{\\setkeys{Gin}{width=3em,keepaspectratio}\\includegraphics{#2}}};}, #1} % Create the new environments for R Markdown \\newenvironment{rmdnote} {\\begin{customBlockImage}{images/note}} {\\end{customBlockImage}} \\newenvironment{rmdimportant} {\\begin{customBlockImage}{images/important}} {\\end{customBlockImage}} % We can also change the colour of the box \\newenvironment{rmdwarning} {\\begin{customBlockImage}[colback=red]{images/important}} {\\end{customBlockImage}} Again, we have designed an output which should be consistent across HTML and PDF outputs. Below we show the output of the rmdnote custom block: This is the rmdnote custom block References "],
["plotting-multiple-figures-side-by-side.html", "9.4 Plotting multiple figures side-by-side", " 9.4 Plotting multiple figures side-by-side As explained in https://bookdown.org/yihui/rmarkdown/r-code.html#figures of Yihui Xie (2018), we can place multiple figures side-by-side using the fig.hold='hold' along with the out.width option. As an example below, we have set the out.width=&quot;50%&quot;: plot(1:10) plot(rnorm(10), pch=19) Figure 9.1: Side-by-side figures The main benefits of this approach is that it is easily achieved, and also works for both PDF and HTML outputs. References "],
["tables.html", "Chapter 10 Tables", " Chapter 10 Tables Tables are one of the primary ways in which we can communicate results in a report, and it can often be desired to tweak the appearance of these to suit our particular needs. In this chapter, we will highlight several techniques which can be used to customise tables. The chapter aims to: explain how we can customise the formatting of tables highlight more advanced customisation of tables using the the kableExtra package provide examples of other packages which can be used to produce tables. "],
["customising-kable-outputs.html", "10.1 Customising kable outputs", " 10.1 Customising kable outputs The kable package provides the most convenient way of producing tables within the R Markdown package, providing neatly formatted tables for PDF, HTML, and Word and Markdown documents. The majority of the time, the default settings are generally suitable, but if we wish to have more control of their behaviour, there is an extensive number of settings which can be used. Table 10.1 shows the possible arguments which can be used, and with some examples shown below on how they can be used. Table 10.1: Possible arguments for the kable function Argument Description HTML LaTeX Markdown digits NA X X X row.names NA X X X col.names NA X X X align NA X X X caption NA X X X format NA X X X escape NA X X - booktabs NA - X - longtable NA - X - linesep NA - X - table.envir NA - X - table.attr NA - X - format.args NA - X - padding NA - - X 10.1.1 Changing column names The names of columns in a dataframe will often not be the same as what we want to display in our output format. It can be particularly annoying to have spaces in the name of a variable. We can use the the col.names argument to replace the names with a vector of names: knitr::kable(head(iris), col.names = c(&quot;Sepal Length&quot;, &quot;Sepal Width&quot;, &quot;Petal Length&quot;, &quot;Petal Width&quot;, &quot;Species&quot;)) Sepal Length Sepal Width Petal Length Petal Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 10.1.2 Changing column alignment If we wish to change the alignment of a knitr table, we can use either a vector of values or a single multi-character string for alignment, so kable(..., align=c('c','l')) can be shortened to kable(..., align='cl'). knitr::kable(head(mtcars), align = &quot;llrrcc&quot;) mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 10.1.3 Customising LaTeX options There are a lot of extra options which can be controlled for LaTeX tables. booktabs booktabs LaTeX package. If we are creating tables which are longer than a page, we can longtable option. This will load the longtable LaTeX package. The caption.short argument can be useful if we wish to show a shortened caption in our table of contents. linesep can be used to change the line spacing. We can play around with this option if you want to change the style. For example linesep = c(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;\\\\hline&quot;) would add a horizontal line every four spaces. 10.1.4 Customising HTML table appearance 10.1.5 Changing default behavour There are many global options which apply to kable which can be set within your R Markdown document. These can be controlled globally within your R Markdown document using the options function. The settings which can be controlled include: options(knitr.kable.NA = '') ADD MORE "],
["kableextra.html", "10.2 kableExtra", " 10.2 kableExtra The kableExtra package (???) is designed to extend the basic functionality of tables produced using kable. As explained by the package author, the intention with using kableExtra is that you can: Use default base kable() for all simple tables Use kable() with kableExtra to generate 90 % of complex/advanced/self-customized/beautiful tables in either HTML or LaTeX Only have to mess with raw HTML/LaTeX in the last 10% cases where kableExtra cannot solve the problem This section aims to provide a quick overview of some of the main principles of kableExtra, and provides some examples of how you may wish to integrate it into your document. For extensive documentation, readers are recommended to check the documentation online, which provides full details on how the outputs can be customised for both HTML and LaTeX outputs. 10.2.1 Setup kableExtra is available to download through CRAN: # Install from CRAN install.packages(&quot;kableExtra&quot;) # install the development version devtools::install_github(&quot;haozhu233/kableExtra&quot;) 10.2.2 Customising HTML Width and position column and row spec bootstrap styling Scroll box 10.2.3 Customising PDF Width and position column and row spec Styling Landscape page You can scale the width of the table using the function kable_styling(latex_options = &quot;scale_down&quot;). This will force the table to the width of the page. kable(iris[1:5,], format = &quot;latex&quot;, booktabs = TRUE) %&gt;% kable_styling(latex_options = &quot;scale_down&quot;) "],
["tableExtensions.html", "10.3 Extension Packages", " 10.3 Extension Packages Although kable offers flexible tables within R Markdown documents, you may wish to extend the functionality of tables using other packages. There are several packages which have been developed to create tables in R Markdown: stargazer (???) gt (???) These packages are explained in the following subsections. 10.3.1 stargazer TO ADD 10.3.2 gt TO ADD "],
["workflow.html", "Chapter 11 Workflow", " Chapter 11 Workflow Tips for running your R Markdown projects. "],
["customRender.html", "11.1 Creating custom render functions", " 11.1 Creating custom render functions "],
["multi-file-documents.html", "11.2 Multi-file documents", " 11.2 Multi-file documents With larger R Markdown projects, it can be useful to split the document into smaller files which are easier to handle than a single, massive '.Rmd document. Also, we may also have generic components which we wish to use across all of our analyses, and rather than copying and pasting the same code across for each report. In this section, we highlight two approaches which can be used when splitting an R Markdown document into separate .Rmd files, using child documents and the bookdown (Xie 2018) package. Most importantly, we will highlight when it is preferred for each to be used within your analysis. 11.2.1 Child documents We can include other R Markdown documents within a file by using child documents. The contents of the child document is loaded into the parent document, and any R code will be run as normally within knitr. To include a child document, we can add a code chunk with the option child, providing the file path to the .Rmd file to be included. The chunk should contain no code but we can specify additional chunk options if we wish to suppress the code output i.e. echo=FALSE. For example: ```{r, child = &quot;about.Rmd&quot;} ``` Whereby the content of about.Rmd provides a short description of the packages used for the analysis: # About This analysis was written in the R programming language [@R-base]. The report was generated using **rmarkdown** [@R-markdown] and **knitr** [@R-knitr]. Child documents are useful where we have a standard piece of text that we wish to include across multiple documents. Rather than copying and pasting the text to each file, we can refer to a single source file. If any changes are made to our generic description at a later date, we can update a single source file and all the reports will be up to date. Further examples where child documents could be useful include: Project Description: it is often useful to include generic description of the project Funding Statements: research will often have the same funding statement used across all outputs R Session Information: you may wish to include document metadata 11.2.2 Using bookdown The bookdown (Xie 2018) package is designed for creating long format documents within R Markdown, and allows us to split our files into multiple components. To demonstrate the use, we provide a minimal example comprising of three files within the same directory: directory |- index.Rmd |- 01-intro.Rmd |- 02-analysis.Rmd index.Rmd: The main detail is that the main file has to be called index.Rmd , and must include the additional YAML line site: bookdown::bookdown_site. We must also use a bookdown output format such as html_document2, pdf_document2, word_document2: --- title: &quot;A Minimal bookdown document&quot; site: bookdown::bookdown_site output: bookdown::pdf_document2 --- Some content 01-intro.Rmd: # Chapter 1 This is chapter 1. 02-analysis.Rmd: # Chapter 2 This is chapter 2. When the file is built, bookdown merges the results of the separate files into a single output document. This will automatically be done in alphabetical order, so it makes sense to precede your file name with a numeric index as above. For a comprehensive overview of the package, readers may refer to the Bookdown Book (Xie 2016) or Chapter 18 of the R Markdown Definitive Guide (Yihui Xie 2018). 11.2.3 Which method should you use? There is a legacy of using child documents when creating longer documents, as bookdown was only released in 2016. As such, there is some confusion over which should be used when. In general, if you are wishing to reuse a component across multiple documents, it is recommended to use child documents. However, if you are wanting to write a book and split it into multiple files (preferably one per chapter), bookdown provides a lot of extra functionality and is generally preferred. References "],
["rstudio-integration-with-r-markdown.html", "11.3 RStudio integration with R Markdown", " 11.3 RStudio integration with R Markdown R Markdown format and features can be used with R and rmarkdown package, with any editor that got your preference. However, RStudio has a deep integration with R Markdown and offers additional feature that will help your project workflow without a doubt. 11.3.1 R Markdown specific Rstudio keyboard shorcuts Like any great IDE, RStudio has keyboard shorcuts2 and some are specific to R Markdown. Some of the most useful shortcuts are summarised in Table 11.1. Table 11.1: Rmarkdown related Rstudio keyboard shorcuts Description Windows &amp; Linux Mac Insert R chunk Ctrl+Alt+I Command+Option+I Preview HTML Ctrl+Shift+K Command+Shift+K Knitr document (knitr) Ctrl+Shift+K Command+Shift+K Compile Notebook Ctrl+Shift+K Command+Shift+K Compile PDF Ctrl+Shift+K Command+Shift+K Run all chunks above Ctrl+Alt+P Command+Option+P Run current chunk Ctrl+Alt+C Command+Option+C Run current chunk Ctrl+Shift+Enter Command+Shift+Enter Run next chunk Ctrl+Alt+N Command+Option+N Run all chunks Ctrl+Alt+R Command+Option+R Go to next chunk/title Ctrl+PgDown Command+PgDown Go to previous chunk/title Ctrl+PgUp Command+PgUp Show/hide document outline Ctrl+Shift+O Command+Shift+O Build book, website, … Ctrl+Shift+B Command+Shift+B 11.3.2 Customising the knit button When you click the Knit button in RStudio, it will run the rmarkdown::render in a clean R session and output a file of the same name in the same directory. For example, running example.Rmd with the output:html_document will create an output file example.html. There may be situations where we want to customise how the document is rendered. For example, perhaps we would like the rendered document to contain the current date, or would like to output the compiled report into a different directory. Although we can customise the render function using external scripts (See section 11.1), it can be inconvenient to have to rely on external scripts to compile your report. It is possible to control the behaviour of the knit button by using the knit argument within the YAML of your document. This requires a function to be specified with the arguments inputFile, and encoding. There are two techniques that we can use to customise the behaviour of the knit function: Embed the custom function directly within the YAML Create a custom function and save it in a package The easiest way of creating a function is to store the code directly within the YAML. We must wrap the entire function in brackets, and any linebreaks in the YAML must start with 4 spaces. For example, if we want the output filename to include the date it was rendered, we could use the following YAML code: --- knit: (function(inputFile, encoding) {rmarkdown::render(input = inputFile, encoding = encoding, output_file = paste0(tools::file_path_sans_ext(basename(inputFile)), &#39;-&#39;, format(Sys.Date(), &quot;%Y%m%d&quot;), &#39;.html&#39;))}) --- For example, we if knitted example.Rmd on 2019/04/22, the output file name would be example-20190422.html. While the above approach does benefit from simplicity, it may get more complicated if we wish to do more advanced behaviour (perhaps creating a directory, setting some other environment variables). Embedding longer functions directly in your YAML may become difficult to manage. It may therefore be worth creating a function which could be used in a package. Taking our example above, we have created an example knit_with_date as defined below: #&#39; Custom Knit function for RStudio #&#39; #&#39; @export knit_with_date &lt;- function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = paste0(dirname(inputFile),&#39;/&#39;, tools::file_path_sans_ext(basename(inputFile)), &#39;-&#39;, format(Sys.Date(), &#39;%Y%m%d&#39;), &#39;.html&#39;)) } If we were to add this to the package myPackage, you will then be able to refer to your custom Knit function using the following YAML argument: --- knit: myPackage::knit_with_date --- Readers may wish to refer to Section 11.1 to find out more ideas on how they could customise the control of their render function. A full list can be found on the web or directly in the IDE under tools menu Tools -&gt; Keyboard Shortcuts Help.↩ "],
["managing-big-projects.html", "Chapter 12 Managing Big Projects", " Chapter 12 Managing Big Projects Practical tips on how a big project should be managed source is particularly useful for loading external scripts so that the R Markdown project isn’t too bloated with code. Ideas: - Use (ref:tag) to store page formatting options which might need to be reused. For example a page break "],
["sourcing-files.html", "12.1 Sourcing Files", " 12.1 Sourcing Files A benefit of using R Markdown is that it is easy source(&quot;yourScript.R&quot;) "],
["caching.html", "12.2 Caching", " 12.2 Caching Caching Ways it can be tailored to suit analysis. This cache invalidation is a great example: https://stackoverflow.com/questions/18376008/invalidate-a-chunks-cache-when-uncached-chunk-changes "],
["notifications.html", "12.3 Notifications", " 12.3 Notifications Can link R Markdown with notifications if have long analysis Working with non R users Use HTML outputs and interactive graphics "],
["altering-citation-style.html", "12.4 Altering Citation Style", " 12.4 Altering Citation Style Using short author citations: https://stackoverflow.com/questions/48303890/using-short-author-citations-in-bookdown-rmarkdown?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa "],
["automatically-generate-package-citations.html", "12.5 Automatically Generate Package Citations", " 12.5 Automatically Generate Package Citations It is important to that an acknowledgements is provided within your work to authors of any literature or software referenced. Within a typical workflow, this can be a frustrating experience if you are required to manually identify the correctly formatted citations, load them into a referencing software and then refer to them within the text. However, R Markdown makes it easy to streamline this process. We can generate a BibTex file for packages used within your analysis using the write_bib function within R Markdown. # automatically create a bib database for R packages knitr::write_bib(c( .packages(), &#39;bookdown&#39;, &#39;knitr&#39;, &#39;rmarkdown&#39;, &#39;DiagrammeR&#39; ), &#39;packages.bib&#39;) To refer to the packages in the text, we must add bibliography: packages.bib to the YAML frontmatter, and then references can be made using the format [@R-package] where package is replaced with the package name i.e. [@R-rmarkdown]. This will be replaced with an intext citation and will be added to the bibliography at the end of your document. Note, that the write_bib command is designed to overwrite the existing bibliography. If you want to manually add any other items to the bibligraphy in your document, it is recommended that you create a second .bib file which is also referred to within the YAML bibliography field, as shown below: --- bibliography: [packages.bib. references.bib] --- "],
["diagrams.html", "Chapter 13 Diagrams", " Chapter 13 Diagrams It is often useful to express analysis using flowcharts and diagrams within reports. Although there are many separate programs which can be used to produce these, it can be beneficial to create these within our analysis directly. This makes it easier to update and edit the graph if we need to edit it in the future, and allows us to use the results from our analysis directly within the diagrams, making them more information. While there are several different packages available for R, we will focus on the package DiagrammeR (Iannone 2019). We also recommend that you read at http://rich-iannone.github.io/DiagrammeR/index.html . In this chapter we will explain some of the basic usages of the package. References "],
["basic-diagrams.html", "13.1 Basic Diagrams", " 13.1 Basic Diagrams DiagrammeR provides methods to build graphs for a number of different graphing languages. R Studio provides native support for Graphviz (.gv) and mermaid (.mmd) files. Using files of these types in RStudio provides the advantage of syntax coloring and allowing a quick preview of the diagram. For example, we can make a simple flowchart with the following code: DiagrammeR::grViz(&quot;digraph { graph [layout = dot, rankdir = LR] node [shape = rectangle] rec1 [label = &#39;Step 1&#39;] rec2 [label = &#39;Step 2&#39;] rec3 [label = &#39;Step 3&#39;] rec4 [label = &#39;Step 4&#39;] # edge definitions with the node IDs rec1 -&gt; rec2 -&gt; rec3 -&gt; rec4 }&quot;, height = 200) Figure 13.1: A basic graphic using DiagrammeR There are extensive controls which can be used to control the shape of nodes, colours, line types and add additional parameters. "],
["adding-parameters-to-plots.html", "13.2 Adding parameters to plots", " 13.2 Adding parameters to plots Graphviz substitution allows for mixing in R expressions into a Graphviz graph specification without sacrificing readability. If you specify a subsitution with @@, you must ensure there is a valid expression for that substitution. The expressions are placed as footnotes and their evaluations must result in an R vector object (i.e., not a data frame, list, or matrix). Because there is the possibility to have multiple substitutions, numbering is required. Thus, the @@ notation is immediately followed by a number and that number should correspond to the number of the footnoted R expression. For example, suppose we have a dataset which is being analysed, and we would like to identify how many values are removed at each stage of a process. DiagrammeR::grViz(&quot; digraph graph2 { graph [layout = dot, rankdir = LR] # node definitions with substituted label text node [shape = rectangle] a [label = &#39;@@1&#39;] b [label = &#39;@@2&#39;] c [label = &#39;@@3&#39;] d [label = &#39;@@4&#39;] a -&gt; b -&gt; c -&gt; d } [1]: paste(&#39;Input Data&#39;, 1) [2]: paste(&#39;Step &#39;, 1) [3]: paste(&#39;Step &#39;, 1) [4]: paste(&#39;Step &#39;, 1) &quot;) "],
["knitr-hooks.html", "Chapter 14 Knitr Hooks", " Chapter 14 Knitr Hooks Hooks offer a useful tool for extending the functionality of knitr. Many of the examples included within this chapter have been integrated into the knitrhooks package, avaialable at https://github.com/nathaneastwood/knitrhook. "],
["hooks-scroll.html", "14.1 Scrollable code chunks", " 14.1 Scrollable code chunks It was shown in Section 7.2 how we can use custom CSS to add a scroll bar to the output code chunks. To highlight the use of code chunks, we extend the example here to allow for user-specified maximum heights to be provided to chunks. Firstly, we define the custom hook. In this chunk, we need to insert the formatting required to style the scroll bar. The variable max_height is used to control the maximum height of the code chunk: knitr::knit_hooks$set(output = function(x, options){ if(!is.null(options$max_height)){ paste(&#39;&lt;pre style = &quot;max-height:&#39;, options$max_height, &#39;;float: left; width: 910px; overflow-y: auto;&quot;&gt;&#39;, x, &quot;&lt;/pre&gt;&quot;, sep = &quot;&quot;) }else{ x } }) To use this option, we can specify the option within the code chunk header. ```{r max_height = &quot;200px&quot;} print(cars) ``` library(knitr) hook_output &lt;- knit_hooks$get(&quot;output&quot;) knit_hooks$set(output = function(x, options) { lines &lt;- options$output.lines if (is.null(lines)) { return(hook_output(x, options)) # pass to default hook } x &lt;- unlist(strsplit(x, &quot;\\n&quot;)) more &lt;- &quot;...&quot; if (length(lines)==1) { # first n lines if (length(x) &gt; lines) { # truncate the output, but add .... x &lt;- c(head(x, lines), more) } } else { x &lt;- c(if (abs(lines[1])&gt;1) more else NULL, x[lines], if (length(x)&gt;lines[abs(length(lines))]) more else NULL ) } # paste these lines together x &lt;- paste(c(x, &quot;&quot;), collapse = &quot;\\n&quot;) hook_output(x, options) }) "],
["references.html", "References", " References "]
]
